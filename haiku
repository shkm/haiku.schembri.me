#!/bin/sh
# Adapted from blurt (https://github.com/shkm/blurt)
set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
DIST="$SCRIPT_DIR/dist"

# Prefer imagemagick-full (has freetype) over regular imagemagick
if [ -x "/opt/homebrew/opt/imagemagick-full/bin/magick" ]; then
  MAGICK="/opt/homebrew/opt/imagemagick-full/bin/magick"
elif command -v magick >/dev/null 2>&1; then
  MAGICK="magick"
else
  MAGICK=""
fi

# Get current time in milliseconds (portable across GNU, BusyBox, macOS)
now_ms() {
  if ts=$(date +%s%N 2>/dev/null) && [ ${#ts} -gt 10 ]; then
    echo $((ts / 1000000))
  elif [ -f /proc/uptime ]; then
    awk '{printf "%.0f", $1 * 1000}' /proc/uptime
  else
    echo $(($(date +%s) * 1000))
  fi
}

slugify() {
  echo "$1" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//'
}

xml_escape() {
  sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/"/\&quot;/g; s/'"'"'/\&apos;/g'
}

generate_favicon() {
  highlight="$1"
  output="$2"

  cat >"$output" <<EOF
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <rect width="100" height="100" rx="12" fill="$highlight"/>
  <text x="51" y="51" font-family="'Open Sans', sans-serif" font-size="32" font-weight="bold" fill="rgba(0,0,0,0.2)" text-anchor="middle" dominant-baseline="central">俳句</text>
  <text x="50" y="50" font-family="'Open Sans', sans-serif" font-size="32" font-weight="bold" fill="#fff" text-anchor="middle" dominant-baseline="central">俳句</text>
</svg>
EOF
}

# Extract haiku body text from a markdown file (everything after second ---, blank lines removed)
extract_haiku_text() {
  awk 'BEGIN{c=0} /^---$/{c++; next} c>=2' "$1" | sed '/^[[:space:]]*$/d'
}

download() {
  if command -v curl >/dev/null 2>&1; then
    curl -fsSL "$1" -o "$2" 2>/dev/null
  elif command -v wget >/dev/null 2>&1; then
    wget -qO "$2" "$1" 2>/dev/null
  fi
}

ensure_fonts() {
  FONT_DIR="$SCRIPT_DIR/.fonts"
  mkdir -p "$FONT_DIR"
  FONT_FILE="$FONT_DIR/FacultyGlyphic-Regular.ttf"
  JP_FONT_FILE="$FONT_DIR/NotoSerifJP-Regular.ttf"
  [ ! -f "$FONT_FILE" ] && download "https://github.com/google/fonts/raw/main/ofl/facultyglyphic/FacultyGlyphic-Regular.ttf" "$FONT_FILE" || true
  [ ! -f "$JP_FONT_FILE" ] && download "https://github.com/google/fonts/raw/main/ofl/notoserifjp/NotoSerifJP%5Bwght%5D.ttf" "$JP_FONT_FILE" || true
}

generate_og_image() {
  text="$1"
  highlight="$2"
  output="$3"
  title="$4"

  [ -z "$MAGICK" ] && return

  font_file="$SCRIPT_DIR/.fonts/FacultyGlyphic-Regular.ttf"
  jp_font="$SCRIPT_DIR/.fonts/NotoSerifJP-Regular.ttf"
  [ ! -f "$font_file" ] && return

  darker=$($MAGICK xc:"$highlight" -modulate 92 -format '%[hex:p{0,0}]' info: 2>/dev/null || echo "${highlight#\#}")

  if [ -n "$title" ]; then
    $MAGICK -size 1200x630 -depth 32 -define gradient:direction=SouthWest gradient:"$highlight-#$darker" \
      -attenuate 0.15 +noise Gaussian \
      -font "$font_file" -pointsize 52 -interline-spacing 20 \
      -fill 'rgba(0,0,0,0.15)' -gravity Center -annotate +1+1 "$text" \
      -fill '#ffffff' -gravity Center -annotate +0+0 "$text" \
      -font "$jp_font" -pointsize 24 -fill 'rgba(255,255,255,0.3)' \
      -gravity NorthWest -annotate +60+50 "俳句" \
      -font "$font_file" -gravity NorthEast -annotate +60+50 "$title" \
      -quality 90 "$output" || true
  else
    $MAGICK -size 1200x630 -depth 32 -define gradient:direction=SouthWest gradient:"$highlight-#$darker" \
      -attenuate 0.15 +noise Gaussian \
      -font "$font_file" -pointsize 52 -interline-spacing 20 \
      -fill 'rgba(0,0,0,0.15)' -gravity Center -annotate +1+1 "$text" \
      -fill '#ffffff' -gravity Center -annotate +0+0 "$text" \
      -font "$jp_font" -pointsize 24 -fill 'rgba(255,255,255,0.3)' \
      -gravity NorthWest -annotate +60+50 "俳句" \
      -quality 90 "$output" || true
  fi
}

cmd_new() {
  open_editor=false
  [ "$1" = "-e" ] && open_editor=true && shift

  title="$1"
  if [ -z "$title" ]; then
    echo "Usage: haiku new [-e] \"Haiku Title\""
    exit 1
  fi

  slug=$(slugify "$title")
  file="$SCRIPT_DIR/posts/$slug.md"

  if [ -f "$file" ]; then
    echo "File already exists: $file"
    exit 1
  fi

  max_order=0
  for p in "$SCRIPT_DIR/posts"/*.md; do
    [ -f "$p" ] || continue
    o=$(sed -n 's/^order: *//p' "$p" | head -1)
    [ -n "$o" ] && [ "$o" -gt "$max_order" ] && max_order="$o"
  done
  next_order=$((max_order + 1))

  cat >"$file" <<EOF
---
title: $title
date: $(date -u +%Y-%m-%d)
order: $next_order
---

EOF

  echo "Created $file"
  if $open_editor; then ${EDITOR:-vi} "$file"; fi
}

cmd_build() {
  if ! command -v pandoc >/dev/null 2>&1; then
    echo "pandoc is required but not installed"
    exit 1
  fi

  ensure_fonts
  build_start=$(now_ms)
  commit_sha="${GITHUB_SHA:-$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")}"

  haiku_template="$SCRIPT_DIR/templates/haiku.html"
  index_template="$SCRIPT_DIR/templates/index.html"
  data_dir="--data-dir=$SCRIPT_DIR"
  config_flag=""
  [ -f "$SCRIPT_DIR/config.yaml" ] && config_flag="--metadata-file=$SCRIPT_DIR/config.yaml"

  # Read config values
  site_url=$(sed -n 's/^site_url: *"\{0,1\}\([^"]*\)"\{0,1\} *$/\1/p' "$SCRIPT_DIR/config.yaml" 2>/dev/null | head -1)
  color=$(sed -n 's/^color: *"\{0,1\}\([^"]*\)"\{0,1\} *$/\1/p' "$SCRIPT_DIR/config.yaml" 2>/dev/null | head -1)
  [ -z "$color" ] && color="#2C3930"

  rm -rf "$DIST"
  mkdir -p "$DIST"

  if [ -d "$SCRIPT_DIR/static" ] && [ "$(ls -A "$SCRIPT_DIR/static" 2>/dev/null)" ]; then
    cp -r "$SCRIPT_DIR/static"/* "$DIST/"
  fi

  posts_data=""

  for post in "$SCRIPT_DIR/posts"/*.md; do
    [ -f "$post" ] || continue
    slug=$(basename "$post" .md)
    title=$(sed -n 's/^title: *//p' "$post" | head -1)
    date=$(sed -n 's/^date: *//p' "$post" | head -1)
    order=$(sed -n 's/^order: *//p' "$post" | head -1)
    [ -z "$order" ] && order=0
    posts_data="$posts_data$order	$date	$slug	$title
"
  done

  sorted=$(printf '%s' "$posts_data" | sort -n -r)
  total=$(echo "$sorted" | grep -c '[^[:space:]]' || true)
  i=0

  echo "$sorted" | while IFS='	' read -r order date slug title; do
    [ -z "$order" ] && continue
    i=$((i + 1))

    post="$SCRIPT_DIR/posts/$slug.md"
    description=$(sed -n 's/^description: *//p' "$post" | head -1)

    # Determine prev/next (sorted newest first: prev=newer, next=older)
    prev_slug=""
    next_slug=""
    [ "$i" -gt 1 ] && prev_slug=$(echo "$sorted" | sed -n "$((i - 1))p" | cut -f3)
    [ "$i" -lt "$total" ] && next_slug=$(echo "$sorted" | sed -n "$((i + 1))p" | cut -f3)

    prev_flag=""
    next_flag=""
    [ -n "$prev_slug" ] && prev_flag="-M prev_slug=$prev_slug"
    [ -n "$next_slug" ] && next_flag="-M next_slug=$next_slug"

    mkdir -p "$DIST/$slug"
    pandoc "$post" -f markdown+hard_line_breaks --template="$haiku_template" $data_dir $config_flag -M slug="$slug" -M pagetitle="$title" -M pagedescription="$description" -M is_post=true $prev_flag $next_flag -o "$DIST/$slug/index.html"

    # Generate OG image with full haiku text centered
    haiku_text=$(extract_haiku_text "$post")
    generate_og_image "$haiku_text" "$color" "$DIST/$slug/og.jpg" "$title"
  done

  index_list=$(echo "$sorted" | sort -n | while IFS='	' read -r order date slug title; do
    [ -z "$order" ] && continue
    printf '<li><a href="%s/">%s</a></li>' "$slug" "$title"
  done)

  site_title=$(sed -n 's/^site_title: *"\{0,1\}\([^"]*\)"\{0,1\} *$/\1/p' "$SCRIPT_DIR/config.yaml" 2>/dev/null | head -1)
  site_description=$(sed -n 's/^site_description: *"\{0,1\}\([^"]*\)"\{0,1\} *$/\1/p' "$SCRIPT_DIR/config.yaml" 2>/dev/null | head -1)
  echo "$index_list" | pandoc --template="$index_template" $data_dir $config_flag -M pagetitle="$site_title" -M pagedescription="$site_description" -o "$DIST/index.html"

  # Generate OG image for homepage
  generate_og_image "$site_title" "$color" "$DIST/og.jpg"
  generate_favicon "$color" "$DIST/favicon.svg"

  # Generate Atom feed
  site_author=$(sed -n 's/^site_author: *"\{0,1\}\([^"]*\)"\{0,1\} *$/\1/p' "$SCRIPT_DIR/config.yaml" 2>/dev/null | head -1)

  if [ -n "$site_url" ]; then
    feed_updated=$(echo "$sorted" | head -1 | cut -f2)
    [ -z "$feed_updated" ] && feed_updated=$(date -u +%Y-%m-%d)
    site_url_escaped=$(echo "$site_url" | xml_escape)

    cat >"$DIST/feed.xml" <<'FEED_HEADER'
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
FEED_HEADER
    printf '  <title>%s</title>\n' "$(echo "$site_title" | xml_escape)" >>"$DIST/feed.xml"
    printf '  <link href="%s/feed.xml" rel="self"/>\n' "$site_url_escaped" >>"$DIST/feed.xml"
    printf '  <link href="%s/"/>\n' "$site_url_escaped" >>"$DIST/feed.xml"
    printf '  <id>%s/</id>\n' "$site_url_escaped" >>"$DIST/feed.xml"
    printf '  <updated>%sT00:00:00Z</updated>\n' "$feed_updated" >>"$DIST/feed.xml"
    [ -n "$site_author" ] && printf '  <author><name>%s</name></author>\n' "$(echo "$site_author" | xml_escape)" >>"$DIST/feed.xml"

    echo "$sorted" | while IFS='	' read -r order date slug title; do
      [ -z "$order" ] && continue
      article=$(sed -n '/<article>/,/<\/article>/p' "$DIST/$slug/index.html")
      title_escaped=$(echo "$title" | xml_escape)
      content_escaped=$(printf '%s' "$article" | xml_escape)
      printf '  <entry>\n' >>"$DIST/feed.xml"
      printf '    <title>%s</title>\n' "$title_escaped" >>"$DIST/feed.xml"
      printf '    <link href="%s/%s/"/>\n' "$site_url_escaped" "$slug" >>"$DIST/feed.xml"
      printf '    <id>%s/%s/</id>\n' "$site_url_escaped" "$slug" >>"$DIST/feed.xml"
      printf '    <updated>%sT00:00:00Z</updated>\n' "$date" >>"$DIST/feed.xml"
      printf '    <content type="html">%s</content>\n' "$content_escaped" >>"$DIST/feed.xml"
      printf '  </entry>\n' >>"$DIST/feed.xml"
    done

    echo "</feed>" >>"$DIST/feed.xml"
  fi

  echo "Built site in $DIST ($(($(now_ms) - build_start))ms)"
}

cmd_start() {
  if ! command -v python3 >/dev/null 2>&1; then
    echo "python3 is required for the dev server"
    exit 1
  fi

  port="${1:-8000}"

  cmd_build

  python3 -m http.server "$port" -d "$DIST" &
  server_pid=$!
  trap "kill $server_pid 2>/dev/null" EXIT

  echo "Serving at http://localhost:$port"

  if command -v fswatch >/dev/null 2>&1; then
    fswatch -o "$SCRIPT_DIR/posts" "$SCRIPT_DIR/templates" "$SCRIPT_DIR/static" "$SCRIPT_DIR/config.yaml" | while read; do
      echo "Rebuilding..."
      cmd_build
    done
  else
    echo "Note: install fswatch for instant rebuilds (currently polling)"
    while true; do
      sleep 1
      changed=$(find "$SCRIPT_DIR/posts" "$SCRIPT_DIR/templates" "$SCRIPT_DIR/static" "$SCRIPT_DIR/config.yaml" -newer "$DIST/index.html" 2>/dev/null | head -1)
      [ -n "$changed" ] && echo "Rebuilding..." && cmd_build
    done
  fi
}

case "$1" in
new)
  shift
  cmd_new "$@"
  ;;
build)
  cmd_build
  ;;
start)
  cmd_start "$2"
  ;;
*)
  echo "Usage: haiku <new|build|start>"
  echo "  new [-e] \"Title\"  - Create a new haiku"
  echo "  build             - Build the site"
  echo "  start [port]      - Watch, rebuild, and serve (default: 8000)"
  exit 1
  ;;
esac
